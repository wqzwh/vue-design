<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue技术内幕 | 句法分析 - 生成真正的AST</title>
    <meta name="description" content="逐行级别的 Vue 源码分析">
    <script async="" src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
    <link rel="preload" href="/vue-design/assets/css/0.styles.a67d9878.css" as="style"><link rel="preload" href="/vue-design/assets/js/app.3ead5cd1.js" as="script"><link rel="preload" href="/vue-design/assets/js/10.37353439.js" as="script"><link rel="prefetch" href="/vue-design/assets/js/15.90af06d8.js"><link rel="prefetch" href="/vue-design/assets/js/1.e03931ed.js"><link rel="prefetch" href="/vue-design/assets/js/2.4e6f232c.js"><link rel="prefetch" href="/vue-design/assets/js/3.8b192dac.js"><link rel="prefetch" href="/vue-design/assets/js/4.c77df884.js"><link rel="prefetch" href="/vue-design/assets/js/5.3eb89d05.js"><link rel="prefetch" href="/vue-design/assets/js/6.e719b88d.js"><link rel="prefetch" href="/vue-design/assets/js/7.80669094.js"><link rel="prefetch" href="/vue-design/assets/js/8.e0a2c67b.js"><link rel="prefetch" href="/vue-design/assets/js/9.f02dea08.js"><link rel="prefetch" href="/vue-design/assets/js/11.19ea2bee.js"><link rel="prefetch" href="/vue-design/assets/js/12.b4d4268d.js"><link rel="prefetch" href="/vue-design/assets/js/13.88286d93.js"><link rel="prefetch" href="/vue-design/assets/js/14.9f4f968e.js"><link rel="prefetch" href="/vue-design/assets/js/16.687e2afa.js"><link rel="prefetch" href="/vue-design/assets/js/17.37d0c762.js"><link rel="prefetch" href="/vue-design/assets/js/18.95e08670.js"><link rel="prefetch" href="/vue-design/assets/js/19.29f38553.js"><link rel="prefetch" href="/vue-design/assets/js/20.0894e504.js"><link rel="prefetch" href="/vue-design/assets/js/21.1e9ee09e.js"><link rel="prefetch" href="/vue-design/assets/js/22.93b2bb1e.js"><link rel="prefetch" href="/vue-design/assets/js/23.b8b3cfc3.js"><link rel="prefetch" href="/vue-design/assets/js/24.86bfc0d0.js"><link rel="prefetch" href="/vue-design/assets/js/25.431a193a.js"><link rel="prefetch" href="/vue-design/assets/js/26.cc474263.js"><link rel="prefetch" href="/vue-design/assets/js/27.ccf0fb25.js"><link rel="prefetch" href="/vue-design/assets/js/28.a20bc4e4.js"><link rel="prefetch" href="/vue-design/assets/js/29.2e798ff0.js"><link rel="prefetch" href="/vue-design/assets/js/30.c90bbf70.js"><link rel="prefetch" href="/vue-design/assets/js/31.1fe561d9.js">
    <link rel="stylesheet" href="/vue-design/assets/css/0.styles.a67d9878.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/vue-design/" class="home-link router-link-active"><!----><span class="site-name">
      Vue技术内幕
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/vue-design/art/" class="nav-link router-link-active">正文</a></div><div class="nav-item"><a href="/vue-design/appendix/" class="nav-link">附录</a></div><div class="nav-item"><a href="/vue-design/more/" class="nav-link">扩展阅读</a></div><div class="nav-item"><a href="/vue-design/donate/" class="nav-link">人之初</a></div><div class="nav-item"><a href="/vue-design/about/" class="nav-link">关于</a></div><a href="https://github.com/HcySunYang/vue-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vue-design/art/" class="nav-link router-link-active">正文</a></div><div class="nav-item"><a href="/vue-design/appendix/" class="nav-link">附录</a></div><div class="nav-item"><a href="/vue-design/more/" class="nav-link">扩展阅读</a></div><div class="nav-item"><a href="/vue-design/donate/" class="nav-link">人之初</a></div><div class="nav-item"><a href="/vue-design/about/" class="nav-link">关于</a></div><a href="https://github.com/HcySunYang/vue-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><div><ins data-ad-client="ca-pub-4613560834313397" data-ad-slot="2465217753" class="adsbygoogle" style="display:inline-block;width:100%;height:120px;"></ins></div><ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>正文(持续更新...)</span><span class="arrow down"></span></p><ul class="sidebar-group-items"><li><a href="/vue-design/art/" class="sidebar-link">前言</a></li><li><a href="/vue-design/art/1start-learn.html" class="sidebar-link">了解 Vue 这个项目</a></li><li><a href="/vue-design/art/2vue-constructor.html" class="sidebar-link">Vue 构造函数</a></li><li><a href="/vue-design/art/3vue-example.html" class="sidebar-link">以一个例子为线索</a></li><li><a href="/vue-design/art/4vue-normalize.html" class="sidebar-link">Vue 选项的规范化</a></li><li><a href="/vue-design/art/5vue-merge.html" class="sidebar-link">Vue 选项的合并</a></li><li><a href="/vue-design/art/6vue-init-start.html" class="sidebar-link">Vue 的初始化之开篇</a></li><li><a href="/vue-design/art/7vue-reactive.html" class="sidebar-link">揭开数据响应系统的面纱</a></li><li><a href="/vue-design/art/8vue-reactive-dep-watch.html" class="sidebar-link">渲染函数的观察者与进阶的数据响应系统</a></li><li><a href="/vue-design/art/9vue-state-init.html" class="sidebar-link">其他重要选项的初始化及实现</a></li><li><a href="/vue-design/art/80vue-compiler-start.html" class="sidebar-link">Vue 的编译器初探</a></li><li><a href="/vue-design/art/81vue-lexical-analysis.html" class="sidebar-link">词法分析 - 为生成AST做准备</a></li><li><a href="/vue-design/art/82vue-parsing.html" class="active sidebar-link">句法分析 - 生成真正的AST</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-design/art/82vue-parsing.html#根据令牌生成ast的思路" class="sidebar-link">根据令牌生成AST的思路</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/82vue-parsing.html#解析前的准备工作" class="sidebar-link">解析前的准备工作</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-design/art/82vue-parsing.html#正则常量-onre" class="sidebar-link">正则常量 onRE</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/82vue-parsing.html#正则常量-dirre" class="sidebar-link">正则常量 dirRE</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/82vue-parsing.html#正则常量-foraliasre" class="sidebar-link">正则常量 forAliasRE</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/82vue-parsing.html#正则常量-foriteratorre" class="sidebar-link">正则常量 forIteratorRE</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/82vue-parsing.html#正则常量-stripparensre" class="sidebar-link">正则常量 stripParensRE</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/82vue-parsing.html#正则常量-argre" class="sidebar-link">正则常量 argRE</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/82vue-parsing.html#正则常量-bindre" class="sidebar-link">正则常量 bindRE</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/82vue-parsing.html#正则常量-modifierre" class="sidebar-link">正则常量 modifierRE</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/82vue-parsing.html#html-实体解码函数-decodehtmlcached" class="sidebar-link">HTML 实体解码函数 decodeHTMLCached</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/82vue-parsing.html#定义平台化选项变量" class="sidebar-link">定义平台化选项变量</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/82vue-parsing.html#createastelement-函数" class="sidebar-link">createASTElement 函数</a></li></ul></li><li class="sidebar-sub-header"><a href="/vue-design/art/82vue-parsing.html#对令牌的加工" class="sidebar-link">对令牌的加工</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-design/art/82vue-parsing.html#增强的-class" class="sidebar-link">增强的 class</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/82vue-parsing.html#增强的-style" class="sidebar-link">增强的 style</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/82vue-parsing.html#特殊的-model" class="sidebar-link">特殊的 model</a></li></ul></li><li class="sidebar-sub-header"><a href="/vue-design/art/82vue-parsing.html#生成抽象语法树-ast" class="sidebar-link">生成抽象语法树(AST)</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/82vue-parsing.html#静态优化" class="sidebar-link">静态优化</a></li></ul></li><li><a href="/vue-design/art/83vue-codegen.html" class="sidebar-link">编译器之代码的生成</a></li><li><a href="/vue-design/art/84vue-vdom.html" class="sidebar-link">虚拟DOM解析</a></li><li><a href="/vue-design/art/85vue-vdom-patch.html" class="sidebar-link">虚拟DOM补丁算法详解</a></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="句法分析-生成真正的ast"><a href="#句法分析-生成真正的ast" aria-hidden="true" class="header-anchor">#</a> 句法分析 - 生成真正的AST</h1><p>在上一章中，我们讲解了解析 <code>html</code> 字符串时词法分析的方式，本章我们将再进一步，讲解 <code>Vue</code> 是如何在词法分析的基础上构建抽象语法树(<code>AST</code>)的，即句法分析。</p><p>打开 <code>src/compiler/index.js</code> 文件，注意如下高亮的那句代码：</p><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> createCompiler <span class="token operator">=</span> <span class="token function">createCompilerCreator</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">baseCompile</span> <span class="token punctuation">(</span>
  template<span class="token punctuation">:</span> string<span class="token punctuation">,</span>
  options<span class="token punctuation">:</span> CompilerOptions
<span class="token punctuation">)</span><span class="token punctuation">:</span> CompiledResult <span class="token punctuation">{</span>
<span class="highlighted-line">  <span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span>template<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span></span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>optimize <span class="token operator">!==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">optimize</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    ast<span class="token punctuation">,</span>
    render<span class="token punctuation">:</span> code<span class="token punctuation">.</span>render<span class="token punctuation">,</span>
    staticRenderFns<span class="token punctuation">:</span> code<span class="token punctuation">.</span>staticRenderFns
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>可以看到 <code>parse</code> 函数的返回值就是抽象语法树(<code>AST</code>)，根据文件头部的引用关系可知 <code>parse</code> 函数来自于 <code>src/compiler/parser/index.js</code> 文件，实际上该文件所有的内容都在做一件事，即创建 <code>AST</code>。</p><p>本章的讲解目标就是 <code>src/compiler/parser/index.js</code> 文件，不过具体到源码之前，我们有必要独立思考一下如何根据词法分析创建一个抽象语法树。</p><h2 id="根据令牌生成ast的思路"><a href="#根据令牌生成ast的思路" aria-hidden="true" class="header-anchor">#</a> 根据令牌生成AST的思路</h2><p>在上一节的末尾我们讲解了 <code>parseHTML</code> 函数的使用，该函数接收一些选项参数，其中包括几个重要的钩子函数，如每当遇到一个开始标签时会调用的 <code>options.start</code> 钩子函数，每当遇到一个结束标签时会调用的 <code>options.end</code> 钩子函数等等。实际上一颗抽象语法树的构建最关键的就是这两个钩子函数，接下来我们简单讲解一下构建抽象语法树的思路。</p><p>假设我们有一段 <code>html</code> 字符串，如下：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>文本<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>那么最终生成的这颗树应该是与如上 <code>html</code> 字符串的结构一一对应的：</p><pre class="language-text"><code>├── ul
│   ├── li
│   │   ├── span
│   │   │   ├── 文本
</code></pre><p>如果每一个节点我们都用一个 <code>javascript</code> 对象来表示的话，那么 <code>ul</code> 标签可以表示为如下对象：</p><pre class="language-js"><code><span class="token punctuation">{</span>
  type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  tag<span class="token punctuation">:</span> <span class="token string">'ul'</span>
<span class="token punctuation">}</span>
</code></pre><p>由于每个节点都存在一个父节点和若干子节点，所以我们为如上对象添加两个属性：<code>parent</code> 和 <code>children</code>，分别用来表示当前节点的父节点和它所包含的子节点：</p><pre class="language-js"><code><span class="token punctuation">{</span>
  type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  tag<span class="token punctuation">:</span> <span class="token string">'ul'</span><span class="token punctuation">,</span>
  parent<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p>同时每个元素节点还可能包含很多属性(<code>attributes</code>)，所以我们可以为每个节点添加 <code>attrsList</code> 属性，用来存储当前节点所拥有的属性：</p><pre class="language-js"><code><span class="token punctuation">{</span>
  type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  tag<span class="token punctuation">:</span> <span class="token string">'ul'</span><span class="token punctuation">,</span>
  parent<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  attrsList<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p>按照以上思路，实际上你可以为节点的描述对象添加任何你需要的属性，从而进一步描述该节点的特征。如果使用如上这个对象描述之前定义的 <code>html</code> 字符串，那么这颗抽象语法树应该长成如下这个样子：</p><pre class="language-js"><code><span class="token punctuation">{</span>
  type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  tag<span class="token punctuation">:</span> <span class="token string">'ul'</span><span class="token punctuation">,</span>
  parent<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  attrsList<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  children<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
      tag<span class="token punctuation">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span>
      parent<span class="token punctuation">:</span> ul<span class="token punctuation">,</span>
      attrsList<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      children<span class="token punctuation">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
          type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
          tag<span class="token punctuation">:</span> <span class="token string">'span'</span><span class="token punctuation">,</span>
          parent<span class="token punctuation">:</span> li<span class="token punctuation">,</span>
          attrsList<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
          children<span class="token punctuation">:</span> <span class="token punctuation">[</span>
            <span class="token punctuation">{</span>
              type<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
              tag<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
              parent<span class="token punctuation">:</span> span<span class="token punctuation">,</span>
              attrsList<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
              text<span class="token punctuation">:</span> <span class="token string">'文本'</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p>实际上构建抽象语法树的工作就是创建一个类似如上所示的一个能够描述节点关系的对象树，节点与节点之间通过 <code>parent</code> 和 <code>children</code> 建立联系，每个节点的 <code>type</code> 属性用来标识该节点的类别，比如 <code>type</code> 为 <code>1</code> 代表该节点为元素节点，<code>type</code> 为 <code>2</code> 代表该节点为文本节点，这只是认为的一个规定，你可以用任何方便的方式加以区分。</p><p>明白了我们的目标，下面我们在回到 <code>parseHTML</code> 函数，因为目前为止我们所拥有的只有这一个函数，我们需要使用该函数构建出一颗如上所述的描述对象。</p><p>首先我们需要定义一个 <code>parse</code> 函数，假设该函数就是用来把 <code>html</code> 字符串生成 <code>AST</code> 的，如下：</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">parse</span> <span class="token punctuation">(</span>html<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> root
  <span class="token comment">//...</span>
  <span class="token keyword">return</span> root
<span class="token punctuation">}</span>
</code></pre><p>如上代码所示，我们在 <code>parse</code> 函数内定义了变量 <code>root</code> 并将其返回，其中 <code>root</code> 所代表的就是整个 <code>AST</code>，<code>parse</code> 函数体中间的所有代码都是为了充实 <code>root</code> 变量。怎么充实呢？这是我们需要借助 <code>parseHTML</code> 函数帮助我们解析 <code>html</code> 字符串，如下：</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">parse</span> <span class="token punctuation">(</span>html<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> root
  
  <span class="token function">parseHTML</span><span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">start</span> <span class="token punctuation">(</span>tag<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> unary<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 省略...</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">end</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 省略...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  
  <span class="token keyword">return</span> root
<span class="token punctuation">}</span>
</code></pre><p>我们从简出发，假设我们要解析的 <code>html</code> 字符串如下：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>这段 <code>html</code> 字符串仅仅是一个简单的 <code>div</code> 标签，甚至没有任何子节点。若要解析如上标签我们可以编写如下代码：</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">parse</span> <span class="token punctuation">(</span>html<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> root
  
  <span class="token function">parseHTML</span><span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">start</span> <span class="token punctuation">(</span>tag<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> unary<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="highlighted-line">      <span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token punctuation">{</span></span><span class="highlighted-line">        type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span></span><span class="highlighted-line">        tag<span class="token punctuation">:</span> tag<span class="token punctuation">,</span></span><span class="highlighted-line">        parent<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span></span><span class="highlighted-line">        attrsList<span class="token punctuation">:</span> attrs<span class="token punctuation">,</span></span><span class="highlighted-line">        children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="highlighted-line">      <span class="token punctuation">}</span></span><span class="highlighted-line"></span><span class="highlighted-line">      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> root <span class="token operator">=</span> element</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">end</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 省略...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  
  <span class="token keyword">return</span> root
<span class="token punctuation">}</span>
</code></pre><p>如上高亮代码所示，在 <code>start</code> 钩子函数中首先定义了 <code>element</code> 常量，它就是元素节点的描述对象，接着判断 <code>root</code> 是否存在，如果不存在则直接将 <code>element</code> 赋值给 <code>root</code>。这段代码对于解析 <code>'&lt;div&gt;&lt;/div&gt;'</code> 这段 <code>html</code> 字符串来说已经足够了，当解析这段 <code>html</code> 字符串时首先会遇到 <code>div</code> 元素的开始标签，此时 <code>start</code> 钩子函数将被调用，最终 <code>root</code> 变量将被设置为：</p><pre class="language-js"><code>root <span class="token operator">=</span> <span class="token punctuation">{</span>
  type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  tag<span class="token punctuation">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
  parent<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  attrsList<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p>但是当解析的 <code>html</code> 字符串稍微复杂一点的时候，这段用来解析的代码就不能正常使用了，比如对于如下这段 <code>html</code> 字符串：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>这段 <code>html</code> 字符串比之前的 <code>html</code> 字符串的不同之处在于 <code>div</code> 标签多了一个子节点，即多了一个 <code>span</code> 标签。如果继续沿用之前的解析代码，当解析如上 <code>html</code> 字符串时首先会遇到 <code>div</code> 元素的开始标签，此时 <code>start</code> 钩子函数被调用，<code>root</code> 变量被设置为：</p><pre class="language-js"><code>root <span class="token operator">=</span> <span class="token punctuation">{</span>
  type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  tag<span class="token punctuation">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
  parent<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  attrsList<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p>接着会遇到 <code>span</code> 元素的开始标签，会再次调用 <code>start</code> 钩子函数，由于此时 <code>root</code> 变量已经存在，所以不会再次设置 <code>root</code> 变量。为了能够更好的解析 <code>span</code> 标签，我们需要多值钱的解析代码做一些改变，如下：</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">parse</span> <span class="token punctuation">(</span>html<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> root
<span class="highlighted-line">  <span class="token keyword">let</span> currentParent</span>  
  <span class="token function">parseHTML</span><span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">start</span> <span class="token punctuation">(</span>tag<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> unary<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token punctuation">{</span>
        type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
        tag<span class="token punctuation">:</span> tag<span class="token punctuation">,</span>
<span class="highlighted-line">        parent<span class="token punctuation">:</span> currentParent<span class="token punctuation">,</span></span>        attrsList<span class="token punctuation">:</span> attrs<span class="token punctuation">,</span>
        children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
      <span class="token punctuation">}</span>

<span class="highlighted-line">      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="highlighted-line">        root <span class="token operator">=</span> element</span><span class="highlighted-line">      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>currentParent<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="highlighted-line">        currentParent<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span></span><span class="highlighted-line">      <span class="token punctuation">}</span></span><span class="highlighted-line">      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>unary<span class="token punctuation">)</span> currentParent <span class="token operator">=</span> element</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">end</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 省略...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  
  <span class="token keyword">return</span> root
<span class="token punctuation">}</span>
</code></pre><p>如上代码所示，首先我们需要定义 <code>currentParent</code> 变量，它的作用是没遇到一个非一元标签，都会将该标签的描述对象作为 <code>currentParent</code> 的值，这样当解析该非一元标签的子节点时，子节点的父级就是 <code>currentParent</code> 变量。另外在 <code>start</code> 钩子函数内部我们在创建 <code>element</code> 描述对象时我们使用 <code>currentParent</code> 的值作为每个元素描述对象的 <code>parent</code> 属性的值。</p><p>如果用以上代码解析如下 <code>html</code> 字符串：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>那么其过程大概是这样的：手下会遇到 <code>div</code> 元素的开始标签，此时由于 <code>root</code> 不存在，并且 <code>currentParent</code> 也不存在，所以会创建一个用于描述该 <code>div</code> 元素的对象，并设置 <code>root</code> 的值如下：</p><pre class="language-js"><code>root <span class="token operator">=</span> <span class="token punctuation">{</span>
  type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  tag<span class="token punctuation">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
  parent<span class="token punctuation">:</span> undefined<span class="token punctuation">,</span>
  attrsList<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p>还没完，由于 <code>div</code> 元素是非一元标签，我们可以看到在 <code>start</code> 钩子函数的末尾有一个 <code>if</code> 条件语句，当一个元素为非一元标签时，会设置 <code>currentParent</code> 为该元素的描述对象，所以此时 <code>currentParent</code> 也是：</p><pre class="language-js"><code>currentParent <span class="token operator">=</span> <span class="token punctuation">{</span>
  type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  tag<span class="token punctuation">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
  parent<span class="token punctuation">:</span> undefined<span class="token punctuation">,</span>
  attrsList<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p>接着解析这段 <code>html</code> 字符串，会遇到 <code>span</code> 元素开始的开始标签，由于此时 <code>root</code> 已经存在，所以 <code>start</code> 钩子函数会执行 <code>else...if</code> 条件的判断，检查 <code>currentParent</code> 是否存在，由于 <code>currentParent</code> 存在，所以会将 <code>span</code> 元素的描述对象添加到 <code>currentParent</code> 的 <code>children</code> 数组中作为子节点，所以最终生成的 <code>root</code> 描述对象为：</p><pre class="language-js"><code>root <span class="token operator">=</span> <span class="token punctuation">{</span>
  type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  tag<span class="token punctuation">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
  parent<span class="token punctuation">:</span> undefined<span class="token punctuation">,</span>
  attrsList<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
      type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
      tag<span class="token punctuation">:</span> <span class="token string">'span'</span><span class="token punctuation">,</span>
      parent<span class="token punctuation">:</span> div<span class="token punctuation">,</span>
      attrsList<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p>到现在为了，我们解析逻辑看上去可以用了，但实际上还是存在问题的，假设我们要解析 <code>html</code> 字符串再稍微复杂一点，如下：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>在之前的基础上 <code>div</code> 元素的子节点多了一个 <code>p</code> 标签，按照现有的解析逻辑在解析这段 <code>html</code> 字符串时，首先会遇到 <code>div</code> 元素的开始标签，此时 <code>root</code> 和 <code>currentParent</code> 将被设置为 <code>div</code> 标签的描述对象。接着会遇到 <code>span</code> 元素的开始标签，此时 <code>span</code> 标签的描述对象将被添加到 <code>div</code> 标签描述对象的 <code>children</code> 数组中，同时别忘了 <code>span</code> 元素也是非一元标签，所以 <code>currentParent</code> 变量会被设置为 <code>span</code> 标签的描述对象。接着继续解析，会遇到 <code>span</code> 元素的结束标签，由于 <code>end</code> 钩子函数什么都没做，直接跳过。再继续解析将遇到 <code>p</code> 元素的开始标签，大家注意，<strong>在解析 <code>p</code> 元素的开始标签时，由于 <code>currentParent</code> 变量引用的是 <code>span</code> 元素的描述对象，所以 <code>p</code> 元素的描述对象将被添加到 <code>span</code> 元素描述对象的 <code>children</code> 数组中，被误认为是 <code>span</code> 元素的子节点</strong>。而事实上 <code>p</code> 标签是 <code>div</code> 元素的字节点，这就是问题所在。</p><p>为了解决这个问题，我们需要每当遇到一个非一元标签的结束标签时，都将 <code>currentParent</code> 变量的值回退到之前的元素描述对象，这样就能够保证当前正在解析的标签拥有正确的父级。当时如何回退呢？若要回退之前的值，那么必然需要一个变量保存之前的值，所以我们需要一个数组 <code>stack</code>，如下代码所示：</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">parse</span> <span class="token punctuation">(</span>html<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> root
  <span class="token keyword">let</span> currentParent
<span class="highlighted-line">  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></span>  
  <span class="token function">parseHTML</span><span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">start</span> <span class="token punctuation">(</span>tag<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> unary<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token punctuation">{</span>
        type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
        tag<span class="token punctuation">:</span> tag<span class="token punctuation">,</span>
        parent<span class="token punctuation">:</span> currentParent<span class="token punctuation">,</span>
        attrsList<span class="token punctuation">:</span> attrs<span class="token punctuation">,</span>
        children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        root <span class="token operator">=</span> element
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>currentParent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        currentParent<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>unary<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        currentParent <span class="token operator">=</span> element
<span class="highlighted-line">        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>currentParent<span class="token punctuation">)</span></span>      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="highlighted-line">    <span class="token function">end</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="highlighted-line">      stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="highlighted-line">      currentParent <span class="token operator">=</span> stack<span class="token punctuation">[</span>stack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span></span><span class="highlighted-line">    <span class="token punctuation">}</span></span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  
  <span class="token keyword">return</span> root
<span class="token punctuation">}</span>
</code></pre><p>如上高亮代码所示，首先我们定义了 <code>stack</code> 常量，它是一个数组，接着我们做了一些修改，每次遇到非一元开始标签的时候，除了设置 <code>currentParent</code> 的值之外，还会将 <code>currentParent</code> 添加到 <code>stack</code> 数组。接着我们在 <code>end</code> 钩子函数中添加了一句代码，也就是说每当遇到一个非一元标签的结束标签时，都会回退 <code>currentParent</code> 变量的值为之前的值，这样我们就修正了当前正在解析的元素的父级元素。</p><p>以上就是根据 <code>parseHTML</code> 函数生成 <code>AST</code> 的基本方式，实际上我们还考虑的还不够周全，比如上面的讲解中我们没有处理一元标签，另外我们还需要处理文本节点和注释节点等等。不过上面的讲解很好的为我们后续对源码的解析做了铺垫，更详细的内容我们将在接下来的源码分析阶段为大家仔细说明。</p><h2 id="解析前的准备工作"><a href="#解析前的准备工作" aria-hidden="true" class="header-anchor">#</a> 解析前的准备工作</h2><p>前面说过，整个 <code>src/compiler/parser/index.js</code> 文件的所做的工作都是在创建 <code>AST</code>，所以我们应该先了解一下这个文件的结构，以方便后续的理解。在改文件的开头定义了一些常量和变量，其中包括一些正则常量，我们后续会详细讲解。</p><p>接着定义了 <code>createASTElement</code> 函数，如下：</p><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createASTElement</span> <span class="token punctuation">(</span>
  tag<span class="token punctuation">:</span> string<span class="token punctuation">,</span>
  attrs<span class="token punctuation">:</span> Array<span class="token operator">&lt;</span>Attr<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  parent<span class="token punctuation">:</span> ASTElement <span class="token operator">|</span> <span class="token keyword">void</span>
<span class="token punctuation">)</span><span class="token punctuation">:</span> ASTElement <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    tag<span class="token punctuation">,</span>
    attrsList<span class="token punctuation">:</span> attrs<span class="token punctuation">,</span>
    attrsMap<span class="token punctuation">:</span> <span class="token function">makeAttrsMap</span><span class="token punctuation">(</span>attrs<span class="token punctuation">)</span><span class="token punctuation">,</span>
    parent<span class="token punctuation">,</span>
    children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p><code>createASTElement</code> 函数用来创建一个元素的描述对象，这样我们在创建元素描述对象时就不需要手动编写对象字面量了，方便的同时还能提高代码整洁性。</p><p>再往下定义了整个文件最重要的一个函数，即 <code>parse</code> 函数，它的结构如下：</p><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">parse</span> <span class="token punctuation">(</span>
  template<span class="token punctuation">:</span> string<span class="token punctuation">,</span>
  options<span class="token punctuation">:</span> CompilerOptions
<span class="token punctuation">)</span><span class="token punctuation">:</span> ASTElement <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token comment">/*
   * 省略...
   * 省略的代码用来初始化一些变量的值，以及创建一些新的变量，其中包括 root 变量，该变量为 parse 函数的返回值，即 AST
   */</span>
  
  <span class="token keyword">function</span> <span class="token function">warnOnce</span> <span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">closeElement</span> <span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>

  <span class="token function">parseHTML</span><span class="token punctuation">(</span>template<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token comment">// 其他选项...</span>
    <span class="token function">start</span> <span class="token punctuation">(</span>tag<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> unary<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 省略...</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>

    <span class="token function">end</span> <span class="token punctuation">(</span>tag<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 省略...</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>

    <span class="token function">chars</span> <span class="token punctuation">(</span>text<span class="token punctuation">:</span> string<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 省略...</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">comment</span> <span class="token punctuation">(</span>text<span class="token punctuation">:</span> string<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 省略...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> root
<span class="token punctuation">}</span>
</code></pre><p>通过如上代码的简化，我们可以清晰的看到 <code>parse</code> 函数的结构，在 <code>parse</code> 函数开头代码用来初始化一些变量的值，以及创建一些新的变量，其中包括 <code>root</code> 变量，该变量为 <code>parse</code> 函数的返回值，即最终的 <code>AST</code>。然后定义了两个函数 <code>warnOnce</code> 和 <code>closeElement</code>。接着调用了 <code>parseHTML</code> 函数，通过上一小节的铺垫，相信大家看到这里已经大概知道了 <code>parse</code> 函数是如何创建 <code>AST</code> 的了。另外我们能够注意到在调用 <code>parseHTML</code> 函数时传递了很多选项，其中包括四个重要的钩子函数选项：<code>start</code>、<code>end</code>、<code>chars</code> 以及 <code>comment</code>。最后 <code>parse</code> 函数将 <code>root</code> 变量返回，也就是最终生成的 <code>AST</code>。</p><p>在 <code>parse</code> 函数的后面，定义了非常多的函数，如下：</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">processPre</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">processRawAttrs</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">processElement</span> <span class="token punctuation">(</span>element<span class="token punctuation">:</span> ASTElement<span class="token punctuation">,</span> options<span class="token punctuation">:</span> CompilerOptions<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">processKey</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">processRef</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">processFor</span> <span class="token punctuation">(</span>el<span class="token punctuation">:</span> ASTElement<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">parseFor</span> <span class="token punctuation">(</span>exp<span class="token punctuation">:</span> string<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token operator">?</span>ForParseResult <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">processIf</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">processIfConditions</span> <span class="token punctuation">(</span>el<span class="token punctuation">,</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">findPrevElement</span> <span class="token punctuation">(</span>children<span class="token punctuation">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">:</span> ASTElement <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">addIfCondition</span> <span class="token punctuation">(</span>el<span class="token punctuation">:</span> ASTElement<span class="token punctuation">,</span> condition<span class="token punctuation">:</span> ASTIfCondition<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">processOnce</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">processSlot</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">processComponent</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">processAttrs</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">checkInFor</span> <span class="token punctuation">(</span>el<span class="token punctuation">:</span> ASTElement<span class="token punctuation">)</span><span class="token punctuation">:</span> boolean <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">parseModifiers</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> string<span class="token punctuation">)</span><span class="token punctuation">:</span> Object <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">makeAttrsMap</span> <span class="token punctuation">(</span>attrs<span class="token punctuation">:</span> Array<span class="token operator">&lt;</span>Object<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Object <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">isTextTag</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">:</span> boolean <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">isForbiddenTag</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">:</span> boolean <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">guardIESVGBug</span> <span class="token punctuation">(</span>attrs<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">checkForAliasModel</span> <span class="token punctuation">(</span>el<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* 省略...*/</span><span class="token punctuation">}</span>
</code></pre><p>我们能够发现这些函数的名字大部分都以 <code>process</code> 开头，并且接收的参数中基本都包含 <code>el</code>，那么 <code>el</code> 是什么呢？实际上 <code>el</code> 就是元素的描述对象，如下：</p><pre class="language-js"><code>el <span class="token operator">=</span> <span class="token punctuation">{</span>
  type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  tag<span class="token punctuation">,</span>
  attrsList<span class="token punctuation">:</span> attrs<span class="token punctuation">,</span>
  attrsMap<span class="token punctuation">:</span> <span class="token function">makeAttrsMap</span><span class="token punctuation">(</span>attrs<span class="token punctuation">)</span><span class="token punctuation">,</span>
  parent<span class="token punctuation">,</span>
  children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p>那么 <code>process*</code> 类的函数接收 <code>el</code> 参数后都做了什么呢？实际上 <code>process*</code> 类函数的作用就是对元素描述对象的进一步处理，比如其中一个函数叫做 <code>processPre</code>，这个函数的作用就是用来检测 <code>el</code> 元素是否拥有 <code>v-pre</code> 属性，如果有 <code>v-pre</code> 属性则会在 <code>el</code> 描述对象上添加一个 <code>pre</code> 属性，如下：</p><pre class="language-js"><code>el <span class="token operator">=</span> <span class="token punctuation">{</span>
  type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  tag<span class="token punctuation">,</span>
  attrsList<span class="token punctuation">:</span> attrs<span class="token punctuation">,</span>
  attrsMap<span class="token punctuation">:</span> <span class="token function">makeAttrsMap</span><span class="token punctuation">(</span>attrs<span class="token punctuation">)</span><span class="token punctuation">,</span>
  parent<span class="token punctuation">,</span>
  children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="highlighted-line">  pre<span class="token punctuation">:</span> <span class="token boolean">true</span></span><span class="token punctuation">}</span>
</code></pre><p>类似的，所有 <code>process*</code> 类函数的作用都是为了让一个元素的描述对象更叫充实，使这个对象能更加详情的描述一个元素，并且这些函数都会用在 <code>parseHTML</code> 函数的钩子选项函数中。</p><p>另外我们也能看到很多非 <code>process*</code> 类的函数，例如 <code>findPrevElement</code>、<code>makeAttrsMap</code> 等等，这些函数实际上就是工具函数。</p><p>以上就是 <code>src/compiler/parser/index.js</code> 文件的整体结构。接下来我们将重新回到该文件的开头部分，来看看都定义了哪些常量或变量。</p><h3 id="正则常量-onre"><a href="#正则常量-onre" aria-hidden="true" class="header-anchor">#</a> 正则常量 onRE</h3><p>接下来我们将讲解定义在该文件中的一系列常量，首先要讲解的 <code>onRE</code> 正则常量，其源码如下：</p><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> onRE <span class="token operator">=</span> <span class="token regex">/^@|^v-on:/</span>
</code></pre><p>这个常量用来匹配以字符 <code>@</code> 或 <code>v-on:</code> 开头的字符串，主要作用是检测标签属性名是否是监听事件的指令。</p><h3 id="正则常量-dirre"><a href="#正则常量-dirre" aria-hidden="true" class="header-anchor">#</a> 正则常量 dirRE</h3><p>正则常量 <code>dirRE</code> 源码如下：</p><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> dirRE <span class="token operator">=</span> <span class="token regex">/^v-|^@|^:/</span>
</code></pre><p>它用来匹配以字符 <code>v-</code> 或 <code>@</code> 或 <code>:</code> 开头的字符串，主要作用是检测标签属性名是否是指令。所以通过这个正则我们可以知道，在 <code>vue</code> 中所以 <code>v-</code> 开头的属性都被认为是指令，另外 <code>@</code> 字符是 <code>v-on</code> 的缩写，<code>:</code> 字符是 <code>v-bind</code> 的缩写。</p><h3 id="正则常量-foraliasre"><a href="#正则常量-foraliasre" aria-hidden="true" class="header-anchor">#</a> 正则常量 forAliasRE</h3><p>其源码如下：</p><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> forAliasRE <span class="token operator">=</span> <span class="token regex">/([^]*?)\s+(?:in|of)\s+([^]*)/</span>
</code></pre><p>该正则包含三个分组，第一个分组为 <code>([^]*?)</code>，该分组是一个惰性匹配的分组，它匹配的内容为任何字符，包括换行符等。第二个分组为 <code>(?:in|of)</code>，该分组用来匹配字符串 <code>in</code> 或者 <code>of</code>，并且该分组是非捕获的分组。第三个分组为 <code>([^]*)</code>，与第一个分组类似，不同的是第三个分组是非惰性匹配。同时每个分组之间都会匹配至少一个空白符 <code>\s+</code>。通过以上说明可知，正则 <code>forAliasRE</code> 用来匹配 <code>v-for</code> 属性的值，并捕获 <code>in</code> 或 <code>of</code> 前后的字符串。假设我们像如下这样使用 <code>v-for</code>：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>obj of list<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>那么正则 <code>forAliasRE</code> 用来匹配字符串 <code>'obj of list'</code>，并捕获到两个字符串 <code>'obj'</code> 和 <code>'list'</code>。</p><h3 id="正则常量-foriteratorre"><a href="#正则常量-foriteratorre" aria-hidden="true" class="header-anchor">#</a> 正则常量 forIteratorRE</h3><p>源码如下：</p><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> forIteratorRE <span class="token operator">=</span> <span class="token regex">/,([^,\}\]]*)(?:,([^,\}\]]*))?$/</span>
</code></pre><p>该正则用来匹配 <code>forAliasRE</code> 第一个捕获组所捕获到的字符串，可以看到如上正则中拥有三个分组，有两个捕获的分组，第一个捕获组用来捕获一个不包含字符 <code>}</code> 和 <code>]</code> 的字符串，且该字符串前面有一个字符 <code>,</code>，如：<code>', index'</code>。第二个分组为非捕获的分组，第三个分组为捕获的分组，其捕获的内容与第一个捕获组相同。</p><p>举几个例子，我们知道 <code>v-for</code> 有几种不同的写法，其中一种使用 <code>v-for</code> 的方式是：</p><pre class="language-js"><code><span class="token operator">&lt;</span>div v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">&quot;obj of list&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre><p>如果像如上这样使用 <code>v-for</code>，那么 <code>forAliasRE</code> 正则的第一个捕获组的内容为字符串 <code>'obj'</code>，此时使用 <code>forIteratorRE</code> 正则去匹配字符串 <code>'obj'</code> 将得不到任何内容。</p><p>第二种使用 <code>v-for</code> 的方式为：</p><pre class="language-js"><code><span class="token operator">&lt;</span>div v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">&quot;(obj, index) of list&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre><p>此时 <code>forAliasRE</code> 正则的第一个捕获组的内容为字符串 <code>'(obj, index)'</code>，如果去掉左右括号则该字符串为 <code>'obj, index'</code>，如果使用 <code>forIteratorRE</code> 正则去匹配字符串 <code>'obj, index'</code> 则会匹配成功，并且 <code>forIteratorRE</code> 正则的第一个捕获组将捕获到字符串 <code>'index'</code>，但第二个捕获组捕获不到任何内容。</p><p>第三种使用 <code>v-for</code> 的方式为：</p><pre class="language-js"><code><span class="token operator">&lt;</span>div v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">&quot;(value, key, index) in object&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre><p>以上方式主要用于遍历对象而非数组，此时 <code>forAliasRE</code> 正则的第一个捕获组的内容为字符串 <code>'(value, key, index)'</code>，如果去掉左右括号则该字符串为 <code>'value, key, index'</code>，如果使用 <code>forIteratorRE</code> 正则去匹配字符串 <code>'value, key, index'</code> 则会匹配成功，并且 <code>forIteratorRE</code> 正则的第一个捕获组将捕获到字符串 <code>'key'</code>，但第二个捕获组将捕获到字符串 <code>'index'</code>。</p><h3 id="正则常量-stripparensre"><a href="#正则常量-stripparensre" aria-hidden="true" class="header-anchor">#</a> 正则常量 stripParensRE</h3><p>源码如下：</p><pre class="language-js"><code><span class="token keyword">const</span> stripParensRE <span class="token operator">=</span> <span class="token regex">/^\(|\)$/g</span>
</code></pre><p>这个捕获组用来捕获要么以字符 <code>(</code> 开头，要么以字符 <code>)</code> 结尾的字符串，或者两者都满足。那么这个正则的作用是什么呢？我们在讲解正则 <code>forIteratorRE</code> 时有个细节不知道大家注意到了没有，就是 <code>forIteratorRE</code> 正则所匹配的字符串是 <code>'obj, index'</code>，而不是 <code>'(obj, index)'</code>，这两个字符串的区别就在于第二个字符串拥有左右括号，所以在使用 <code>forIteratorRE</code> 正则之前，需要使用 <code>stripParensRE</code> 正则去掉字符串 <code>'(obj, index)'</code> 中的左右括号，实现方式很简单：</p><pre class="language-js"><code><span class="token string">'(obj, index)'</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>stripParensRE<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
</code></pre><h3 id="正则常量-argre"><a href="#正则常量-argre" aria-hidden="true" class="header-anchor">#</a> 正则常量 argRE</h3><p>源码如下：</p><pre class="language-js"><code><span class="token keyword">const</span> argRE <span class="token operator">=</span> <span class="token regex">/:(.*)$/</span>
</code></pre><p>正则 <code>argRE</code> 用来匹配指令中的参数，如下：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click.stop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>handleClick<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>其中 <code>v-on</code> 为指令，<code>click</code> 为传递给 <code>v-on</code> 指令的参数，<code>stop</code> 为修饰符。所以 <code>argRE</code> 正则用来匹配指令编写中的参数，并且拥有一个捕获组，用来捕获参数的名字。</p><h3 id="正则常量-bindre"><a href="#正则常量-bindre" aria-hidden="true" class="header-anchor">#</a> 正则常量 bindRE</h3><p>源码如下：</p><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> bindRE <span class="token operator">=</span> <span class="token regex">/^:|^v-bind:/</span>
</code></pre><p>该正则用来匹配以字符 <code>:</code> 或字符串 <code>v-bind:</code> 开头的字符串，主要用来检测一个标签的属性是否是绑定(<code>v-bind</code>)。</p><h3 id="正则常量-modifierre"><a href="#正则常量-modifierre" aria-hidden="true" class="header-anchor">#</a> 正则常量 modifierRE</h3><p>源码如下：</p><pre class="language-js"><code><span class="token keyword">const</span> modifierRE <span class="token operator">=</span> <span class="token regex">/\.[^.]+/g</span>
</code></pre><p>该正则用来匹配修饰符的，但是并没有捕获任何东西，举例如下：</p><pre class="language-js"><code><span class="token keyword">const</span> matchs <span class="token operator">=</span> <span class="token string">'v-on.click.stop'</span><span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>modifierRE<span class="token punctuation">)</span>
</code></pre><p>那么 <code>matchs</code> 数组第一个元素为字符串 <code>'.stop'</code>，所以指令名字应该是：</p><pre class="language-js"><code>matchs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">// 'stop'</span>
</code></pre><h3 id="html-实体解码函数-decodehtmlcached"><a href="#html-实体解码函数-decodehtmlcached" aria-hidden="true" class="header-anchor">#</a> HTML 实体解码函数 decodeHTMLCached</h3><p>源码如下：</p><pre class="language-js"><code><span class="token keyword">const</span> decodeHTMLCached <span class="token operator">=</span> <span class="token function">cached</span><span class="token punctuation">(</span>he<span class="token punctuation">.</span>decode<span class="token punctuation">)</span>
</code></pre><p><code>cached</code> 函数我们前面遇到过，它的作用是接收一个函数作为参数并返回一个新的函数，新函数的功能与作为参数传递的函数功能相同，唯一不同的是多了新函数将会缓存值，如果一个函数在接收相同参数的情况下所返回的值总是相同的，那么 <code>cached</code> 函数将会为该函数提供性能提升的优势。</p><p>可以看到传递给 <code>cached</code> 函数的参数是 <code>he.decode</code> 函数，其中 <code>he</code> 为第三方的库，<code>he.decode</code> 函数用于 <code>HTML</code> 字符实体的解码工作，如：</p><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>he<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span><span class="token string">'&amp;#x26;'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// &amp;#x26; -&gt; '&amp;'</span>
</code></pre><p>由于字符实体 <code>&amp;#x26;</code> 代表的字符为 <code>&amp;</code>。所以字符串 <code>&amp;#x26;</code> 经过解码后将变为字符 <code>&amp;</code>。<code>decodeHTMLCached</code> 函数在后面将被用于对纯文本的解码，如果不进行解码，那么用户将无法使用字符实体编写字符。</p><h3 id="定义平台化选项变量"><a href="#定义平台化选项变量" aria-hidden="true" class="header-anchor">#</a> 定义平台化选项变量</h3><p>再往下，定义了一些平台化的选项变量，如下：</p><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">let</span> warn<span class="token punctuation">:</span> any
<span class="token keyword">let</span> delimiters
<span class="token keyword">let</span> transforms
<span class="token keyword">let</span> preTransforms
<span class="token keyword">let</span> postTransforms
<span class="token keyword">let</span> platformIsPreTag
<span class="token keyword">let</span> platformMustUseProp
<span class="token keyword">let</span> platformGetTagNamespace
</code></pre><p>上面的代码中定义了 <code>7</code> 个平台化的变量，为什么说上面这些变量为平台化的选项变量呢？后面当我们讲解 <code>parse</code> 函数时，我们能够看到这些变量将被初始化一个值，这些值都是平台化的编译器选项参数，不同平台这些变量将被初始化的值是不同的。我们可以找到 <code>parse</code> 函数看一下：</p><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">parse</span> <span class="token punctuation">(</span>
  template<span class="token punctuation">:</span> string<span class="token punctuation">,</span>
  options<span class="token punctuation">:</span> CompilerOptions
<span class="token punctuation">)</span><span class="token punctuation">:</span> ASTElement <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  warn <span class="token operator">=</span> options<span class="token punctuation">.</span>warn <span class="token operator">||</span> baseWarn

  platformIsPreTag <span class="token operator">=</span> options<span class="token punctuation">.</span>isPreTag <span class="token operator">||</span> no
  platformMustUseProp <span class="token operator">=</span> options<span class="token punctuation">.</span>mustUseProp <span class="token operator">||</span> no
  platformGetTagNamespace <span class="token operator">=</span> options<span class="token punctuation">.</span>getTagNamespace <span class="token operator">||</span> no

  transforms <span class="token operator">=</span> <span class="token function">pluckModuleFunction</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>modules<span class="token punctuation">,</span> <span class="token string">'transformNode'</span><span class="token punctuation">)</span>
  preTransforms <span class="token operator">=</span> <span class="token function">pluckModuleFunction</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>modules<span class="token punctuation">,</span> <span class="token string">'preTransformNode'</span><span class="token punctuation">)</span>
  postTransforms <span class="token operator">=</span> <span class="token function">pluckModuleFunction</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>modules<span class="token punctuation">,</span> <span class="token string">'postTransformNode'</span><span class="token punctuation">)</span>

  delimiters <span class="token operator">=</span> options<span class="token punctuation">.</span>delimiters

  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre><p>如上代码所示，可以清晰的看到在 <code>parse</code> 函数的一开始为这 <code>7</code> 个平台化的变量进行了初始化，初始化的值都是我们曾经讲过的编译器的选项参数，由于我们前面所讲解的都是 <code>web</code> 平台下的编译器选项，所以这里初始化的值都只用于 <code>web</code> 平台。</p><h3 id="createastelement-函数"><a href="#createastelement-函数" aria-hidden="true" class="header-anchor">#</a> createASTElement 函数</h3><p>在平台化变量的后面，定义了 <code>createASTElement</code> 函数，这个函数的作用就是方便我们创建一个节点，或者说方便我们创建一个元素的描述对象，如下：</p><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createASTElement</span> <span class="token punctuation">(</span>
  tag<span class="token punctuation">:</span> string<span class="token punctuation">,</span>
  attrs<span class="token punctuation">:</span> Array<span class="token operator">&lt;</span>Attr<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  parent<span class="token punctuation">:</span> ASTElement <span class="token operator">|</span> <span class="token keyword">void</span>
<span class="token punctuation">)</span><span class="token punctuation">:</span> ASTElement <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    tag<span class="token punctuation">,</span>
    attrsList<span class="token punctuation">:</span> attrs<span class="token punctuation">,</span>
    attrsMap<span class="token punctuation">:</span> <span class="token function">makeAttrsMap</span><span class="token punctuation">(</span>attrs<span class="token punctuation">)</span><span class="token punctuation">,</span>
    parent<span class="token punctuation">,</span>
    children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>它接收三个参数，分别是标签名字 <code>tag</code>，该标签拥有的属性数组 <code>attrs</code> 以及该标签的父标签描述对象的引用。比如我们使用 <code>parseHTML</code> 解析如下标签时：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>obj of list<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>box<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>当遇 <code>div</code> 的开始标签时 <code>parseHTML</code> 函数的 <code>start</code> 钩子函数的前连个参数分别是：</p><pre class="language-js"><code><span class="token keyword">const</span> html <span class="token operator">=</span> <span class="token string">'&lt;div v-for=&quot;obj of list&quot; class=&quot;box&quot;&gt;&lt;/div&gt;'</span>
<span class="token function">parseHTML</span><span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">start</span> <span class="token punctuation">(</span>tag<span class="token punctuation">,</span> attrs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span>    <span class="token comment">// 'div'</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>attrs<span class="token punctuation">)</span>  <span class="token comment">// [ { name: 'v-for', value: 'obj of list' }, { name: 'class', value: 'box' } ]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>此时我们只需要调用 <code>createASTElement</code> 函数并将这两个参数传递过去，即可创建该 <code>div</code> 标签的描述对象：</p><pre class="language-js"><code><span class="token keyword">const</span> html <span class="token operator">=</span> <span class="token string">'&lt;div v-for=&quot;obj of list&quot; class=&quot;box&quot;&gt;&lt;/div&gt;'</span>
<span class="token function">parseHTML</span><span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">start</span> <span class="token punctuation">(</span>tag<span class="token punctuation">,</span> attrs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span>    <span class="token comment">// 'div'</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>attrs<span class="token punctuation">)</span>  <span class="token comment">// [ { name: 'v-for', value: 'obj of list' }, { name: 'class', value: 'box' } ]</span>
<span class="highlighted-line">    <span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token function">createASTElement</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> attrs<span class="token punctuation">)</span></span>  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>最终创建出来的元素描述对象如下：</p><pre class="language-js"><code>element <span class="token operator">=</span> <span class="token punctuation">{</span>
  type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  tag<span class="token punctuation">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
  attrsList<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      name<span class="token punctuation">:</span> <span class="token string">'v-for'</span><span class="token punctuation">,</span>
      value<span class="token punctuation">:</span> <span class="token string">'obj of list'</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      name<span class="token punctuation">:</span> <span class="token string">'class'</span><span class="token punctuation">,</span>
      value<span class="token punctuation">:</span> <span class="token string">'box'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  attrsMap<span class="token punctuation">:</span> <span class="token function">makeAttrsMap</span><span class="token punctuation">(</span>attrs<span class="token punctuation">)</span><span class="token punctuation">,</span>
  parent<span class="token punctuation">,</span>
  children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p>上面的描述对象中的 <code>parent</code> 属性我们没有细说，其实在上一小节我们讲解思路的时候已经接触过 <code>currentParent</code> 变量的作用，实际上元素描述对象间的引用关系就是通过 <code>currentParent</code> 完成的，后面会仔细讲解。另外我们注意到描述对象中除了 <code>attrsList</code> 属性是原始的标签属性数组之后，还有一个叫做 <code>attrsMap</code> 属性：</p><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>
<span class="highlighted-line">  attrsMap<span class="token punctuation">:</span> <span class="token function">makeAttrsMap</span><span class="token punctuation">(</span>attrs<span class="token punctuation">)</span><span class="token punctuation">,</span></span>  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre><p>这个属性是什么呢？可以看到它的值是 <code>makeAttrsMap</code> 函数的返回值，并且 <code>makeAttrsMap</code> 函数接收一个参数，该参数恰好是标签的属性数组 <code>attrs</code>，此时我们需要查看一下 <code>makeAttrsMap</code> 的代码，如下：</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">makeAttrsMap</span> <span class="token punctuation">(</span>attrs<span class="token punctuation">:</span> Array<span class="token operator">&lt;</span>Object<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Object <span class="token punctuation">{</span>
  <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> attrs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>
      process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span>
      map<span class="token punctuation">[</span>attrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isIE <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isEdge
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'duplicate attribute: '</span> <span class="token operator">+</span> attrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    map<span class="token punctuation">[</span>attrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> attrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>value
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> map
<span class="token punctuation">}</span>
</code></pre><p>我们首先注意 <code>makeAttrsMap</code> 函数的第一句代码和最后一句代码，第一句代码定义了 <code>map</code> 常量并在最后一句代码中将其返回，在这两句代码中间是一个 <code>for</code> 循环，用于遍历 <code>attrs</code> 数组，注意 <code>for</code> 循环内有这样一句代码：</p><pre class="language-js"><code>map<span class="token punctuation">[</span>attrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> attrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>value
</code></pre><p>也就是说，如果标签的属性数组 <code>attrs</code> 为：</p><pre class="language-js"><code>attrs <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token string">'v-for'</span><span class="token punctuation">,</span>
    value<span class="token punctuation">:</span> <span class="token string">'obj of list'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token string">'class'</span><span class="token punctuation">,</span>
    value<span class="token punctuation">:</span> <span class="token string">'box'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre><p>那么最终生成的 <code>map</code> 对象则是：</p><pre class="language-js"><code>map <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token string">'v-for'</span><span class="token punctuation">:</span> <span class="token string">'obj of list'</span><span class="token punctuation">,</span>
  <span class="token string">'class'</span><span class="token punctuation">:</span> <span class="token string">'box'</span>
<span class="token punctuation">}</span>
</code></pre><p>所以 <code>makeAttrsMap</code> 函数的作用就是将标签的属性数组转换成名值对一一对象的对象。这么做坑定是有目的的，我们后面遇到了再讲，总之最终生成的元素描述对象如下：</p><pre class="language-js"><code>element <span class="token operator">=</span> <span class="token punctuation">{</span>
  type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  tag<span class="token punctuation">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
  attrsList<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      name<span class="token punctuation">:</span> <span class="token string">'v-for'</span><span class="token punctuation">,</span>
      value<span class="token punctuation">:</span> <span class="token string">'obj of list'</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      name<span class="token punctuation">:</span> <span class="token string">'class'</span><span class="token punctuation">,</span>
      value<span class="token punctuation">:</span> <span class="token string">'box'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  attrsMap<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token string">'v-for'</span><span class="token punctuation">:</span> <span class="token string">'obj of list'</span><span class="token punctuation">,</span>
    <span class="token string">'class'</span><span class="token punctuation">:</span> <span class="token string">'box'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  parent<span class="token punctuation">,</span>
  children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p>以上就是 <code>parse</code> 函数之前定义的所有常量、变量以及函数的讲解，接下来我们将正式进入 <code>parse</code> 函数的实现讲解。</p><h2 id="对令牌的加工"><a href="#对令牌的加工" aria-hidden="true" class="header-anchor">#</a> 对令牌的加工</h2><h3 id="增强的-class"><a href="#增强的-class" aria-hidden="true" class="header-anchor">#</a> 增强的 class</h3><h3 id="增强的-style"><a href="#增强的-style" aria-hidden="true" class="header-anchor">#</a> 增强的 style</h3><h3 id="特殊的-model"><a href="#特殊的-model" aria-hidden="true" class="header-anchor">#</a> 特殊的 model</h3><h2 id="生成抽象语法树-ast"><a href="#生成抽象语法树-ast" aria-hidden="true" class="header-anchor">#</a> 生成抽象语法树(AST)</h2><h2 id="静态优化"><a href="#静态优化" aria-hidden="true" class="header-anchor">#</a> 静态优化</h2></div><div class="content edit-link"><a href="https://github.com/HcySunYang/vue-design/edit/master/docs/art/82vue-parsing.md" target="_blank" rel="noopener noreferrer">错别字纠正</a><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/vue-design/art/81vue-lexical-analysis.html" class="prev">
          词法分析 - 为生成AST做准备
        </a></span><span class="next"><a href="/vue-design/art/83vue-codegen.html">
          编译器之代码的生成
        </a> →
      </span></p></div></div></div></div>
    <script src="/vue-design/assets/js/10.37353439.js" defer></script><script src="/vue-design/assets/js/app.3ead5cd1.js" defer></script>
  </body>
</html>
